---
layout:     post
title:      "Redis相关知识"
subtitle:   "待进一步完善"
date:       2020-03-11
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - Redis
---



## 原理

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换，单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。*（单线程的缺点？？）*
- 采用了非阻塞 I/O 多路复用机制
- 使用了`epoll`，`epoll`中的读、写、关闭、连接都转化成了事件

## 数据类型

- String
  - 一个可变的字节数组，String是动态字符串
- Hash
  - 底层类似`Java`的`HashMap`
- List
  - 存储结构是双向链表。但不是简单的双向链表，是称之为快速链表`quicklist`，首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是`ziplist`，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成`quicklist`。
  - `rpush/rpop/lpush/lpop`
- Set
  - 底层同Hash结构，和`Java` 的`HashSet`一样，所有的value都指向同一个内部值。
- Zset  
  - 有序集合`SortedSet`
  - 给每一个元素value赋予一个权重`score`，另一方面它又类似于`TreeSet`，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过`score`的范围来获取元素的列表。
  - 底层实现使用了`Hash`和跳表，`Hash`的作用就是关联元素`value`和权重`score`，可以通过元素`value`找到相应的`score`值。跳表给元素`value`排序，根据`score`的范围获取元素列表。
  - 跳表是基于多指针有序链表实现的，可以看成多个有序链表，是可以实现二分查找的有序链表

## 底层数据结构

- 哈希表

- 跳跃表

  - 空间复杂度O(n)，查询、插入、删除的时间复杂度为O(log n)

### 为什么Redis选择使用跳表而不是红黑树来实现有序集合?

Redis 中的有序集合(zset) 支持的操作：
1. 插入一个元素
2. 删除一个元素
3. 查找一个元素
4. 有序输出所有元素
5. 按照范围区间查找元素

其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。

## 特性

- 持久化
  - RDB持久性以指定的时间间隔执行数据集的时间点快照。
    - 优点
      - RDB最大限度地提高了Redis性能，因为为了保持Redis父进程所需做的惟一工作就是创建一个将完成所有其余工作的子进程。父实例永远不会执行磁盘I/O或类似的操作。
      - 与AOF相比，RDB允许对大数据集进行更快的重启。
    - 缺点
      - 断电后，不能最小化数据丢失，最新的数据容易丢失
      - RDB利用fork()产生子进程来做持久化存储，但是数据集很大时，fork()可能会很耗时。AOF同样需要fork()，但是可以调整重写日志的频率。
  - AOF持久性记录服务器接收到的每个写入操作，这些操作将在服务器启动时重放，重新构建原始数据集。命令使用与Redis协议本身相同的格式记录，以append-only的方式记录。当日志变得太大时，Redis能够在后台重写日志。
    - 优点
      - 
    - 缺点
      - 对于相同的数据集，AOF文件通常比等效的RDB文件大。
- 事务
  - Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。
- Lua脚本

## Redis的三种模式：主从、哨兵、集群

- 主从
  - 主从复制：
    - Slave启动成功连接到Master后会发送一个sync命令
    - Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，Master将传送整个数据文件到Slave，以完成一次完全同步
- 哨兵
  - Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。
- 集群
  - Redis Cluster采用

## Redis 与 Memcached区别

- 分布式
  - Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。
  - Redis Cluster 实现了分布式的支持。
- 数据类型
  - Memcached 支持String，二进制类型（新版增加）。Redis支持String、List、Set、Hash、ZSet。
- 内存管理
  - Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高。
- 持久化
  - Memcached没有持久化，Redis有RDB和AOF。
- 查询操作
  - Redis支持批量操作还有事务支持，不同类型的CRUD。
- 网络IO模型
  - Redis单线程

## 使用场景

- 分布式锁实现
- 消息队列
- 会话缓存
- 查找表
- 计数器
- 缓存

## 数据淘汰策略

1. **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）
5. **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction**：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0版本后增加以下两种：

1. **volatile-lfu**：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
2. **allkeys-lfu**：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key

## 存在的问题

- 缓存穿透

  - 提供一个能迅速判断请求是否有效的拦截机制，比如，利用**布隆过滤器**，内部维护一系列合法有效的 Key。
  - 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。

- 缓存雪崩

  - 给缓存的失效时间，加上一个随机值，避免集体失效

  

