---
layout:     post
title:      "Redis相关知识"
subtitle:   "待进一步完善"
date:       2020-03-11
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - Redis
---



## 原理

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换，单线程指的是网络请求模块使用了一个线程，即一个线程处理所有网络请求，其他模块仍用了多个线程。
- 采用了非阻塞 I/O 多路复用机制
- 使用了`epoll`，`epoll`中的读、写、关闭、连接都转化成了事件

## 数据类型

- String
  - 一个可变的字节数组，String是动态字符串
- Hash
  - 底层类似`Java`的`HashMap`
- List
  - 存储结构是双向链表。但不是简单的双向链表，是称之为快速链表`quicklist`，首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是`ziplist`，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成`quicklist`。
  - `rpush/rpop/lpush/lpop`
- Set
  - 底层同Hash结构，和`Java` 的`HashSet`一样，所有的value都指向同一个内部值。
- Zset  
  - 有序集合`SortedSet`
  - 给每一个元素value赋予一个权重`score`，另一方面它又类似于`TreeSet`，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过`score`的范围来获取元素的列表。
  - 底层实现使用了`Hash`和跳表，`Hash`的作用就是关联元素`value`和权重`score`，可以通过元素`value`找到相应的score值。跳表给元素value排序，根据score的范围获取元素列表。
  - 跳表是基于多指针有序链表实现的，可以看成多个有序链表。

## 底层数据结构

- 哈希表

- 跳跃表



## 特性

- 持久化
  - RDB持久性以指定的时间间隔执行数据集的时间点快照。
    - 优点
      - RDB最大限度地提高了Redis性能，因为为了保持Redis父进程所需做的惟一工作就是创建一个将完成所有其余工作的子进程。父实例永远不会执行磁盘I/O或类似的操作。
      - 与AOF相比，RDB允许对大数据集进行更快的重启。
    - 缺点
      - 断电后，不能最小化数据丢失，最新的数据容易丢失
      - RDB利用fork()产生子进程来做持久化存储，但是数据集很大时，fork()可能会很耗时。AOF同样需要fork()，但是可以调整重写日志的频率。
  - AOF持久性记录服务器接收到的每个写入操作，这些操作将在服务器启动时重放，重新构建原始数据集。命令使用与Redis协议本身相同的格式记录，以append-only的方式记录。当日志变得太大时，Redis能够在后台重写日志。
    - 优点
      - 
    - 缺点
      - 对于相同的数据集，AOF文件通常比等效的RDB文件大。

- 事务
- Lua脚本

## Redis的三种模式：主从、哨兵、集群

- 主从
- 哨兵
  - Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。
- 集群
  - Redis Cluster采用

## Redis 与 Memcached区别

- 分布式
  - Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。
  - Redis Cluster 实现了分布式的支持。
- 数据类型
  - Memcached只支持String
- 内存管理
  - Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高。
- 持久化
  - Memcached没有持久化

## 使用场景

- 分布式锁实现
- 消息队列
- 会话缓存
- 查找表
- 计数器
- 缓存



## 存在的问题

- 缓存穿透

  - 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。
  - 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。

- 缓存雪崩

  - 给缓存的失效时间，加上一个随机值，避免集体失效

  

