## 一面 8.20 （1h30min）
最开始当然都是自我介绍。
1.  kafka优点，项目中为什么用kafka
    1. **缓冲和削峰**：
       - 上游数据可能会出现突发流量，而下游系统可能无法立即处理这些数据或没有足够的机器来保证冗余。
       - Kafka作为中间层可以充当缓冲，将消息暂时存储在Kafka中，以便下游服务可以按照自己的节奏逐步处理。
    2. **解耦和扩展性**：
       - 在项目初期，往往无法确定具体需求。消息队列可以作为接口层，解耦重要的业务流程。
       - 只需遵守约定，针对数据进行编程，即可获得扩展能力。
    3. **冗余**：
       - Kafka支持一对多的方式，一个生产者发布的消息可以被多个订阅了同一Topic的服务消费，供多个毫无关联的业务使用。
    4. **健壮性**：
       - 消息队列可以堆积请求，即使消费端短时间内死掉，也不会影响主要业务的正常进行。
    5. **异步通信**：
       - 用户不总是需要立即处理消息。消息队列提供异步处理机制，允许用户将消息放入队列，稍后再处理。
2.  kafka为什么吞吐量高
3.  kafka怎么保证数据不丢失
4.  描述项目中使用限流算法，固定窗口，url+userId
5.  项目中的接口归一化是怎么设计的
6.  Java的基础数据类型有哪些
7.  int几个字节，int数据范围，为什么，float的底层表示（IEEE 754），0.2的表示
8.  非受检异常和受检异常
9.  LinkedHashMap是什么，及其原理
10.  HashMap的中的hash函数，怎么做的，作用是什么？（对key的hashcode的扰动，低16位和高16位进行异或），以及为什么是采用低16位和高16位进行异或？
11.  HashMap的put操作，原先1.7的头插法的有什么问题
12.  头插法为什么换成尾插法，具体描述下死循环的过程
13.  什么时候转成红黑树，什么是红黑树
14.  ConcurrentHashMap，put的过程，resize的过程
15.  Redis的常用数据结构，及其底层的数据结构（散列表，压缩列表，链表，跳表，SDS等等）
16.  SDS的优点有哪些？
17.  set的底层结构，整数集合inset 或者散列表hashtable
18.  zset的底层结构 ,（有序集合的编码可以是ziplist或者skiplist） ，具体什么时候用压缩列表，使用压缩列表的条件是什么？
19.  跳表查询，给定value，去zset查询，需要的时间复杂度
20.  归并排序是什么

算法题： 链表的归并排序

## 二面 8.29（1h）
二面忘记录音，有些问题忘了。

1.  线程池，线程池为什么要有最大线程池和工作队列，为什么要两者，怎么考虑设计

2.  抛硬币的先手赢的概率，需要推导过程（计算每次的概率，求数学期望）

算法题： 
1. 100w行字符串，每行小于100个字符，字符限定在a-z（使用Trie就可以了）

2. 判断BST

## 三面 9.4 （50min）



使用zset判断25%分位的数据

ZRANGE，ZCARD



算法题：把二叉搜索树转化成双向链表
