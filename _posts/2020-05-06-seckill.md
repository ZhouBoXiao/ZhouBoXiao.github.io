---
layout:     post
title:      "seckill秒杀系统设计"
subtitle:   "seckill相关知识"
date:       2020-05-05
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - 系统设计
---

## 分流

### 静态文件服务器

在Java开发过程以及生产环境中，最常用的web应用服务器当属Tomcat，尽管这只猫也能够处理一些静态请求，例如图片、html、样式文件等，但是效率并不是那么尽人意。所以在生产环境中，我们一般使用Nginx代理服务器来处理静态文件，来提升网站性能。

```
server {
        listen  80;
        server_name  file.52itstyle.com;
        charset utf-8;
        #root 指令用来指定文件在服务器上的基路径
        root /data/statics;
        #location指令用来映射请求到本地文件系统
        location / {
           autoindex on; # 索引
           autoindex_exact_size on; # 显示文件大小
           autoindex_localtime on; # 显示文件时间
        }
   }

```

### 负载均衡

Nginx 提供轮询（round robin）、IP 哈希（client IP）和加权轮询 3 种方式，默认情况下，Nginx 采用的是轮询。

#### 轮询（默认）
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 
`````
upstream backserver { 
    server 192.168.1.14; 
    server 192.168.1.15; 
} 
`````
#### 加权轮询
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 
```
upstream backserver { 
    server 192.168.1.14 weight=1; 
    server 192.168.1.15 weight=2; 
} 
```
####  ip_hash
每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 
```
upstream backserver { 
    ip_hash; 
    server 192.168.0.14; 
    server 192.168.0.15; 
} 
```

#### 重试策略
可以为每个 backserver 指定最大的重试次数，和重试时间间隔,所使用的关键字是 max_fails 和 fail_timeout。
```
upstream backserver { 
server 192.168.1.14  weight=1  max_fails=2 fail_timeout=30s; 
server 192.168.1.15  weight=2  max_fails=2 fail_timeout=30s;
} 
```
失败重试次数为3，且超时时间为30秒。

#### 热机策略
```
upstream backserver { 
    server 192.168.1.14  weight=1  max_fails=2 fail_timeout=30s; 
    server 192.168.1.15  weight=2  max_fails=2 fail_timeout=30s;

    server 192.168.1.16 backup;
}
```

## 分布式锁解决Redis的并发竞争

- 基于缓存（Redis等）实现分布式锁；
- 基于Zookeeper实现分布式锁

**cdn静态化**

## **链接加盐**

**URL动态化**，就连写代码的人都不知道，你就通过MD5之类的加密算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。

```java
//创建path
public String createMiaoshaPath(MiaoshaUser user, long goodsId) {
		if(user == null || goodsId <=0) {
			return null;
		}
		String str = MD5Utils.md5(UUIDUtil.uuid()+"123456");
		redisService.set(MiaoshaKey.getMiaoshaPath, ""+user.getNickname() + "_"+ goodsId, str);
		return str;
	}

//验证path
boolean check = miaoshaService.checkPath(user, goodsId, path);

public boolean checkPath(MiaoshaUser user, long goodsId, String path) {
		if(user == null || path == null) {
			return false;
		}
		String pathOld = redisService.get(MiaoshaKey.getMiaoshaPath, ""+user.getNickname() + "_"+ goodsId, String.class);
		return path.equals(pathOld);
	}
```

**负载均衡**

## **主从同步**

### 数据库的主从

1. schemas.xml  -- Mycat对应的物理数据库和数据库表的配置

   ```
   schema 是第一个，与server.xml配置的名称相对应
   table 里表明student 表，主键是id,有两个dataNode节点，这两个节点是用来水平分片的，规则就是rule定义的ruleById.
   dataNode节点标明物理数据库和物理主机
   dataHost 设置具体的数据库
       balance=”0”, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上
       balance=”1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡
       balance=”2”，所有读操作都随机的在 writeHost、 readhost 上分发。
       balance=”3”， 所有读请求随机的分发到 wiriterHost 对应的 readhost 执行,writerHost 不负担读压力
   writeType 设置 写入方式的，负载均衡方式可以设置
   ```

   

## **缓存预热**

缓存、尽量不要让大量请求穿透到DB层，活动开始前商品信息可以推送至分布式缓存。

**服务单一职责**

**MQ异步消费消息**

发送消息

RabbitMQ监听消息，监听秒杀队列：

```java
@RabbitListener(queues=MQConfig.MIAOSHA_QUEUE)
public void receive(String message) {
	log.info("receive message:"+message);
	MiaoshaMessage mm  = RedisService.stringToBean(message, MiaoshaMessage.class);
	MiaoshaUser user = mm.getUser();
	long goodsId = mm.getGoodsId();
	//判断库存  查数据库
	GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
	int stock = goods.getStockCount();
	if(stock <= 0) {return;}
	
    //判断是否已经秒杀到了  查Redis缓存
    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(Long.valueOf(user.getNickname()), goodsId);
	if(order != null) {return;}
	
    //减库存 下订单 写入秒杀订单
	miaoshaService.miaosha(user, goods);
}
```

声明式事务，开启一个事务，把减库存和下订单放在一个事务中。

```java
@Transactional
public OrderInfo miaosha(MiaoshaUser user, GoodsVo goods) {
	//减库存 下订单 写入秒杀订单
	boolean success = goodsService.reduceStock(goods);
	if(success){
		return orderService.createOrder(user,goods) ;
	}else {
		//如果库存不存在则内存标记为true
		setGoodsOver(goods.getId());
		return null;
	}
}
```

## **缓存一致性**

### 数据库与缓存数据一致性问题

1. 缓存必须要有过期时间
2. 保证数据库跟缓存的最终一致性即可，不必追求强一致性

1、Cache Aside Pattern

（1）读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应

（2）更新的时候，先删除缓存，然后再更新数据库

### 为什么？

- 先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，**缓存中是旧数据，数据出现不一致**
- 比如可能更新了某个表的一个字段，然后其对应的缓存，是需要查询另外两个表的数据，并进行运算，才能计算出缓存最新的值的。**更新缓存的代价是很高的**。这个缓存到底会不会被频繁访问到呢？
- 其实删除缓存，而不是更新缓存，就是一个**lazy计算的思想**，不要每次都重新做复杂的计算，不管它会不会用到，而是让它到需要被使用的时候再重新计算

#### 数据库与缓存更新与读取操作进行异步串行化

- 更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个jvm内部的队列中

- 读取数据的时候，如果发现数据不在缓存中，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也发送同一个jvm内部的队列中，一个队列对应一个工作线程

- 每个工作线程串行拿到对应的操作，然后一条一条的执行

- 这样的话，一个数据变更的操作，先执行，删除缓存，然后再去更新数据库，但是还没完成更新

- 此时如果一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成

**高并发**

**防止负库存（判断库存和原子性操作）**

加库存用Lua，




## 秒杀主流程

```java
public ResultGeekQ<Integer> miaosha(Model model, MiaoshaUser user, @PathVariable("path") 									String path,@RequestParam("goodsId") long goodsId) {
 
    //验证path
    boolean check = miaoshaService.checkPath(user, goodsId, path);
    if (!check) {
    	result.withError(REQUEST_ILLEGAL.getCode(), REQUEST_ILLEGAL.getMessage());
        return result;
    }
    //是否已经秒杀到 ， 查缓存
    MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(Long.valueOf(user.getNickname()), goodsId);
    if (order != null) {
        result.withError(REPEATE_MIAOSHA.getCode(), REPEATE_MIAOSHA.getMessage());
        return result;
    }
    
    //内存标记，减少redis访问，
    boolean over = localOverMap.get(goodsId);
    if (over) {
        result.withError(MIAO_SHA_OVER.getCode(), MIAO_SHA_OVER.getMessage());
        return result;
    }
    //预减库存
    Long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, "" + goodsId);
    if (stock < 0) {
        localOverMap.put(goodsId, true);
        result.withError(MIAO_SHA_OVER.getCode(), MIAO_SHA_OVER.getMessage());
        return result;
    }
    // 往消息队列中发送消息
    MiaoshaMessage mm = new MiaoshaMessage();
    mm.setGoodsId(goodsId);
    mm.setUser(user);
    mqSender.sendMiaoshaMessage(mm);
    return result;
}
```