---
layout:     post
title:      "设计模式相关"
subtitle:   "设计模式的一些问题"
date:       2020-03-29
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - 设计模式


---

还待进一步完善

# 七大原则

- 单一职责
- 接口隔离
  - 最小接口
- 依赖倒转
  - 抽象不应该依赖细节，细节应该依赖抽象，中心思想是面向接口编程
  - 三种实现方式：接口传递、构造方法传递、setter方式传递
- 里氏替换
  - 所有引用基类的地方必须透明地使用其子类对象。
  - 在子类中尽量不要重写父类的方法
  - 继承让两个类的耦合性增强了，在适当情况下，可以通过聚合、组合、依赖来解决问题。
- 开闭原则
  - 对扩展开发（对提供方），对修改关闭（对使用方）。软件需要改变时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
- 迪米特法则
  - 最少知道原则，一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管有多么复杂，都尽量将逻辑封装在类的内部，对外除了提供public方法，不对外泄露任何信息。
  - 只与直接的朋友通信。直接的朋友：出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部中的类不是直接的朋友。
- 合成复用原则
  - 尽量使用合成/聚合的方式，而不是使用继承

# UML类图

- 依赖
  - 类中用到了对方，那么它们之间就存在依赖关系
- 泛化
  - 继承关系，依赖关系的特例
- 实现
  - A类实现B接口
- 关联
  - 类与类之间的联系，具有单向和双向关系，具有多重性
  - 如单向一对一关系，双向一对一关系
- 聚合
  - 整体和部分的关系，整体与部分可以分开。是关联关系的特例
- 组合
  - 整体和部分的关系，整体与部分不可以分开。
# 设计模式
设计模式分为三种类型，共23种
1. 创建型模式：单例模式、抽象工厂、原型模式、建造者模式、工厂模式。
2. 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
3. 行为模式：模板方法模式、命令模式、访问者模式、迭代模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式

## 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局控制点.

```
public class InnerClassSingleton {
    /**
     * 基于类初始化
     */
    private static class InstanceHolder {
        public static InnerClassSingleton instance = new InnerClassSingleton();
    }
    public static InnerClassSingleton getInstance() {
        return InstanceHolder.instance;
    }
}
```



```
public class DoubleCheckSingleton {
    private static volatile DoubleCheckSingleton instance;
	
    private DoubleCheckSingleton() {}

    //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题
    //同时保证了效率, 推荐使用
    public static DoubleCheckSingleton getInstance() {
        if(instance == null) {
            synchronized (DoubleCheckSingleton.class) {
                if(instance == null) {
                    instance = new DoubleCheckSingleton();
                }
            }
            
        }
        return instance;
    }
}

```



```
 //使用枚举，可以实现单例, 推荐
public enum Singleton {
    INSTANCE; //属性
    public Singleton getInstance() {
        return Singleton.INSTANCE;
    }
}
```



## 策略模式

定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.

## 简单工厂模式和策略模式的区别

- 策略模式
  - 定义个策略接口，不同的实现类提供不同的具体策略算法, 同时它们之间可以互相替换.

- 简单工厂模式
  - 定义一个用以创建对象的工厂, 根据不同的条件生成不同的对象

- 简单工厂模式是根据给定的条件返回相应的对象，而策略模式是将不同的策略对象传递给使用者以实现不同策略。
- 在简单工厂模式中实现了通过条件选取一个类去实例化对象，策略模式则将选取相应对象的工作交给模式的使用者，它本身不去做选取工作。

## 工厂模式

针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例



## 抽象工厂模式

应对产品族概念而生，与工厂模式相比，抽象工厂模式是为了应对产品族

​	

## 装饰者模式

动态的给一个对象添加一些额外的功能

## 代理模式

封装被代理对象并限制外界对被代理对象的访问。

```
interface ITeacherDao {
    void teach(); // 授课的方法
    void sayHello(String name);
}
class TeacherDao implements ITeacherDao {

    @Override
    public void teach() {
        // TODO Auto-generated method stub
        System.out.println(" 老师授课中.... ");
    }
    @Override
    public void sayHello(String name) {
        // TODO Auto-generated method stub
        System.out.println("hello " + name);
    }
}
class ProxyFactory {
    //维护一个目标对象 , Object
    private Object target;
    //构造器 ， 对target 进行初始化
    public ProxyFactory(Object target) {

        this.target = target;
    }

    //给目标对象 生成一个代理对象
    public Object getProxyInstance() {

        //说明
		/*
		 *  public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)

            //1. ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定
            //2. Class<?>[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型
            //3. InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行的目标对象方法作为参数传入
		 */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    // TODO Auto-generated method stub
                    System.out.println("JDK代理开始~~");
                    //反射机制调用目标对象的方法
                    Object returnVal = method.invoke(target, args);
                    System.out.println("JDK代理提交");
                    return returnVal;
                });
    }
}
public class Client {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        //创建目标对象
        ITeacherDao target = new TeacherDao();

        //给目标对象，创建代理对象, 可以转成 ITeacherDao
        ITeacherDao proxyInstance = (ITeacherDao)new ProxyFactory(target).getProxyInstance();

        // proxyInstance=class com.sun.proxy.$Proxy0 内存中动态生成了代理对象
        System.out.println("proxyInstance=" + proxyInstance.getClass());

        //通过代理对象，调用目标对象的方法
        //proxyInstance.teach();

        proxyInstance.sayHello(" tom ");
    }
}

```



## 模板方法模式

定义一个操作的算法骨架, 并将一些步骤延迟到子类中。

该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大。一般模板方法都加上final关键字，防止子类重写模板方法。

使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤 在实现时可能不同，通常考虑用模板方法模式来处理。



## 外观模式

是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

## 适配器模式

将一个类的接口转换成客户希望的另一个接口

## 桥接模式

将抽象部分与实现部分分离，使它们都可以独立的变化

## 建造者模式

将一个复杂对象的构建与它的表示分离.

## 观察者模式

定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者.

## 享元模式



## 命令模式

命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间调用关系更加灵活，实现解耦。在命令模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求，同时命令模式也支持可撤销的操作。

- Invoker 发送  Command ，Receiver接受并根据ConcreteCommand调用方法执行。

```
interface Command {
    public void execute();
    public void undo();
}
public class NoCommand implements Command {

    @Override
    public void execute() {
        // TODO Auto-generated method stub

    }

    @Override
    public void undo() {
        // TODO Auto-generated method stub

    }

}
public class LightReceiver {

    public void on() {
        System.out.println(" 电灯打开了.. ");
    }

    public void off() {
        System.out.println(" 电灯关闭了.. ");
    }
}
class LightOffCommand implements Command {

    // 聚合LightReceiver
    LightReceiver light;

    // 构造器
    public LightOffCommand(LightReceiver light) {
        super();
        this.light = light;
    }

    @Override
    public void execute() {
        // TODO Auto-generated method stub
        // 调用接收者的方法
        light.off();
    }

    @Override
    public void undo() {
        // TODO Auto-generated method stub
        // 调用接收者的方法
        light.on();
    }
}
class LightOnCommand implements Command {

    //聚合LightReceiver
    LightReceiver light;

    //构造器
    public LightOnCommand(LightReceiver light) {
        super();
        this.light = light;
    }

    @Override
    public void execute() {
        // TODO Auto-generated method stub
        //调用接收者的方法
        light.on();
    }

    @Override
    public void undo() {
        // TODO Auto-generated method stub
        //调用接收者的方法
        light.off();
    }
}
public class RemoteController {

    // 开 按钮的命令数组
    Command[] onCommands;
    Command[] offCommands;

    // 执行撤销的命令
    Command undoCommand;

    // 构造器，完成对按钮初始化

    public RemoteController() {

        onCommands = new Command[5];
        offCommands = new Command[5];

        for (int i = 0; i < 5; i++) {
            onCommands[i] = new NoCommand();
            offCommands[i] = new NoCommand();
        }
    }

    // 给我们的按钮设置你需要的命令
    public void setCommand(int no, Command onCommand, Command offCommand) {
        onCommands[no] = onCommand;
        offCommands[no] = offCommand;
    }

    // 按下开按钮
    public void onButtonWasPushed(int no) { // no 0
        // 找到你按下的开的按钮， 并调用对应方法
        onCommands[no].execute();
        // 记录这次的操作，用于撤销
        undoCommand = onCommands[no];

    }

    // 按下开按钮
    public void offButtonWasPushed(int no) { // no 0
        // 找到你按下的关的按钮， 并调用对应方法
        offCommands[no].execute();
        // 记录这次的操作，用于撤销
        undoCommand = offCommands[no];

    }

    // 按下撤销按钮
    public void undoButtonWasPushed() {
        undoCommand.undo();
    }
}

```

