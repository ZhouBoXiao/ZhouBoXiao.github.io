---
layout:     post
title:      "weblogic CVE-2020-2555"
subtitle:   "weblogic CVE-2020-2555 远程执行漏洞"
date:       2020-09-22
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - Java
	- CVE
	- weblogic
---

## CVE-2020-2555
​       通过 oracle weblogic 服务器中的反序列化错误实现 RCE。不安全的反序列化漏洞已经成为针对 javaweb 应用程序的攻击者的一个热门目标。这些漏洞通常会导致可靠的远程代码执行，并且通常很难修补。

​       源是攻击者可以使用给定参数调用Java方法。在 Java 中，为了重新创建对象graph，将自动调用类的 readObject ()或 readExternal ()方法。对于反序列化gadgets来说，这两个方法以及其中可访问的任何其他方法都可以被视为有效的源。

   CVE-2020-2555的补丁对 LimitFilter 类的 toString ()方法进行了修改，对 extract ()方法的所有调用都已从 toString ()中删除。

接着来看下没打补丁之前LimitFilter类的toString()方法。

因为可以通过各种标准 JRE 类(如 BadAttributeValueExpException)的 readObject ()方法访问 toString () :

   ```java
private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
        ObjectInputStream.GetField gf = ois.readFields();
        Object valObj = gf.get("val", null);

        if (valObj == null) {
            val = null;
        } else if (valObj instanceof String) {
            val= valObj;
        } else if (System.getSecurityManager() == null
                || valObj instanceof Long
                || valObj instanceof Integer
                || valObj instanceof Float
                || valObj instanceof Double
                || valObj instanceof Byte
                || valObj instanceof Short
                || valObj instanceof Boolean) {
            val = valObj.toString(); //toString()在这里被调用
        } else { // the serialized object is from a version without JDK-8019292 fix
            val = System.identityHashCode(valObj) + "@" + valObj.getClass().getName();
        }
    }
   ```

​        如上面的代码所示，可以使用 BadAttributeValueExpException 类的序列化实例调用任意类的 toString ()方法。此可用于到达受此补丁影响的 LimitFilter 类的 toString ()方法。

   Sink是已知具有危险副作用的 Java 方法调用。这种副作用的例子有:

- 通过调用 FileOutputStream.write ()任意创建文件。

- 通过调用 runtime.exe ()执行任意命令。

- 通过调用 Method.invoke ()任意调用方法。

​        对于这个漏洞，我们的重点是对 Method.invoke ()的调用，它的副作用是通过反射调用任意的 Java 方法。根据这些信息，我们可以查找所有实例，在这些实例中，extract ()方法调用(我们将其标识为分析补丁的入口点)导致调用 Method.invoke ()。在 Coherence 库中似乎只有一个这样的序列化类的实例(实现 Serializable 或 Externalizable 接口)。

```java
public E extract(T oTarget) {
        if (oTarget == null) {
            return null;
        } else {
            Class clz = oTarget.getClass();

            try {
                Method method = this.m_methodPrev;
                if (method == null || method.getDeclaringClass() != clz) {
                    this.m_methodPrev = method = ClassHelper.findMethod(clz, this.getMethodName(), ClassHelper.getClassArray(this.m_aoParam), false);
                }

                return method.invoke(oTarget, this.m_aoParam); //通过这个方法开始调用
            } catch (NullPointerException var4) {
                throw new RuntimeException(this.suggestExtractFailureCause(clz));
            } catch (Exception var5) {
                throw ensureRuntimeException(var5, clz.getName() + this + '(' + oTarget + ')');
            }
        }
    }

public void readExternal(DataInput in) throws IOException {
        this.m_sMethod = readUTF(in);  // 可以控制的方法
        int cParams = readInt(in);    // 可以控制的参数
        Object[] aoParam = cParams == 0 ? null : new Object[cParams];

        for(int i = 0; i < cParams; ++i) {
            aoParam[i] = readObject(in);
        }

        this.m_aoParam = aoParam;
        this.m_nTarget = readInt(in);
    }
```

   ReflectionExtractor 提供了一个危险的原语，它允许我们调用任意方法，其中方法和参数都可以由攻击者控制。

### 通往 RCE 之路

通常，需要多个方法调用才能实现远程代码执行。例如，在流行的 Apache Commons Collections gadgets 中，这是通过使用 ChainedTransformer 链接任意方法调用来实现的。类似地，Coherence 库中有一个类允许我们链接 extract ()调用，这个类方便地命名为 ChainedExtractor: 

```java
public E extract(Object oTarget) {
        ValueExtractor[] aExtractor = this.getExtractors();
        int i = 0; 

        for(int c = aExtractor.length; i < c && oTarget != null; ++i) {
            oTarget = aExtractor[i].extract(oTarget);
        }

        return oTarget;
    }
```

将所有这些放在一起意味着可以使用以下链来实现远程代码执行:

```java
BadAttributeValueExpException.readObject()
	com.tangosol.util.filter.LimitFilter.toString()
		com.tangosol.util.extractor.ChainedExtractor.extract()
    		com.tangosol.util.extractor.ReflectionExtractor.extract()
    			Method.invoke()
    			...
    			com.tangosol.util.extractor.ReflectionExtractor.extract()
    			Method.invoke()
    				Runtime.exec()
```

因此，任何使用 Coherence 库的项目，只要能够交付恶意的序列化对象，都可以被用于远程代码执行。





**相关概念**

为了能够更好的理解本文稿中所描述 RMI、IIOP、GIOP、CORBA 等协议名称，下面来进行简单介绍。

**1.RMI**
RMI英文全称为Remote Method Invocation，字面的意思就是远程方法调用，其实本质上是RPC服务的JAVA实现，底层实现是JRMP协议，TCP/IP作为传输层。通过RMI可以方便调用远程对象就像在本地调用一样方便。使用的主要场景是分布式系统。

**2.LDAP**

LDAP（Lightweight Directory Access Protocol ，轻型目录访问协议）是一种目录服务协议，运行在TCP/IP堆栈之上。LDAP目录服务是由目录数据库和一套访问协议组成的系统，目录服务是一个特殊的数据库，用来保存描述性的、基于属性的详细信息，能进行查询、浏览和搜索，以树状结构组织数据。LDAP目录服务基于客户端-服务器模型，它的功能用于对一个存在目录数据库的访问。 LDAP目录和RMI注册表的区别在于是前者是目录服务，并允许分配存储对象的属性。常见应用于查询多，修改少的场景，比如通讯录，统一身份认证等。

**3.JNDI**

JNDI (Java Naming and Directory Interface) ，包括Naming Service和Directory Service。JNDI是Java API，允许客户端通过名称发现和查找数据、对象。这些对象可以存储在不同的命名或目录服务中，例如远程方法调用（RMI），公共对象请求代理体系结构（CORBA），轻型目录访问协议（LDAP）或域名服务（DNS）。

Naming Service：命名服务是将名称与值相关联的实体，称为"绑定"。它提供了一种使用"find"或"search"操作来根据名称查找对象的便捷方式。 就像DNS一样，通过命名服务器提供服务，大部分的J2EE服务器都含有命名服务器 。例如上面说到的RMI Registry就是使用的Naming Service。

Directory Service：是一种特殊的Naming Service，它允许存储和搜索"目录对象"，一个目录对象不同于一个通用对象，目录对象可以与属性关联，因此，目录服务提供了对象属性进行操作功能的扩展。一个目录是由相关联的目录对象组成的系统，一个目录类似于数据库，不过它们通常以类似树的分层结构进行组织。可以简单理解成它是一种简化的RDBM系统，通过目录具有的属性保存一些简单的信息,常见的就是LDAP。

JNDI好处：
JNDI自身并不区分客户端和服务器端，也不具备远程能力，但是被其协同的一些其他应用一般都具备远程能力，JNDI在客户端和服务器端都能够进行一些工作，客户端上主要是进行各种访问，查询，搜索，而服务器端主要进行的是帮助管理配置，也就是各种bind。比如在RMI服务器端上可以不直接使用Registry进行bind，而使用JNDI统一管理，当然JNDI底层应该还是调用的Registry的bind，但好处JNDI提供的是统一的配置接口，把RMI换成其他的例如LDAP、CORBA等也是同样的道理。

**4. IIOP**

Internet Inter-ORB Protocol(互联网内部对象请求代理协议)







