---
layout:     post
title:      "面试相关"
subtitle:   "面试相关的一些问题"
date:       2020-04-09
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - 面试
---

## NIO

- 非阻塞IO，实现了IO多路复用中的Reactor模型，一个线程Thread使用一个选择器Selector通过轮询的方式去监听多个通道Channel上的事件，从而让一个线程就可以处理多个事件。
- 通过配置监听的通道Channel为非阻塞，那么当Channel上的IO事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其他Channel，找到IO事件已经到达的Channel执行。
- 对于IO密集型的应用具有很好的性能。

# BigInteger实现原理

- BigInteger存储大数的方式就是将数字存储在一个整型的数组中。

- signum属性是为了区分：正负数和0的标志位，整数用1表示，负数用-1表示，零用0表示

- mag是magnitude的缩写形式，mag数组存储BigInteger数值大小

  - **big-endian** 的顺序，即：高位字节存入低地址，低位字节存入高地址，依次排列的方式

- 如何mag数组转换为原来的数串

  - 不断做除法取余

## BigDecimal实现原理

```java
public class BigDecimal {
    //值的绝对long型表示
    private final transient long intCompact;
    //值的小数点后的位数
    private final int scale;
 
    private final BigInteger intVal;
    //值的有效位数，不包含正负符号
    private transient int precision;
    private transient String stringCache;
     
    //加、减、乘、除、绝对值
    public BigDecimal add(BigDecimal augend) {}
    public BigDecimal subtract(BigDecimal subtrahend) {}
    public BigDecimal multiply(BigDecimal multiplicand) {}
    public BigDecimal divide(BigDecimal divisor) {}
    public BigDecimal abs() {}
}
```



## 影响服务器的最大请求数有哪些因素

- 硬件的上的限制，比如CPU、内存

- 文件句柄的限制

  - 文件句柄进程级限制

    - 在linux下每一个tcp连接都要占一个文件描述符，如果达到上限，就会出现错误：“Socket/File:Can’t open so many files”。操作系统对可以打开的最大文件数有限制。执行 `ulimit -n` 输出 1024，说明对于一个进程而言最多只能打开1024个文件，所以你要采用此默认配置最多也就可以并发上千个TCP连接。临时修改：`ulimit -n 1000000`。`/etc/security/limits.conf`文件`soft nofile 1000000`。

    - 永久修改

      编辑`/etc/rc.local`，在其后添加`ulimit -SHn 1000000`

  - 文件句柄全局限制

    - 执行 `cat /proc/sys/fs/file-nr `，输出 9344 0 592026。分别为：1.已经分配的文件句柄数，2.已经分配但没有使用的文件句柄数，3.最大文件句柄数。

- 端口范围限制

  - 操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。

## 服务端如何识别每个请求对应哪个用户

- Cookie通过在客户端记录信息确定用户身份**，**Session通过在服务器端记录信息确定用户身份。

- Session对象是在客户端第一次请求服务器的时候创建的。
- Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。
- 为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就自动失效了。

## 线程池

**ThreadPoolExecutor 类**

```java
 /**
     * 用给定的初始参数创建一个新的ThreadPoolExecutor。
     */
    public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               ) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```

**`ThreadPoolExecutor` 7 个参数：**

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，信任就会被存放在队列中。
- **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销
- **`unit`** : `keepAliveTime` 参数的时间单位。
- **`threadFactory`** :executor 创建新线程的时候会用到。
- **`handler`** :饱和策略。关于饱和策略下面单独介绍一下。

**`ThreadPoolExecutor` 饱和策略定义:**

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，`ThreadPoolTaskExecutor` 定义一些策略:

- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException`来拒绝新任务的处理。
- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
- `ThreadPoolExecutor.DiscardPolicy`： 不处理新任务，直接丢弃掉。
- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。