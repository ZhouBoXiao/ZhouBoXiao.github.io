---
layout:     post
title:      "Jvm相关知识"
subtitle:   "待进一步完善"
date:       2020-04-06
author:     "ZBX"
header-img: "img/tag-bg.jpg"
tags:
    - Jvm
---



## GCRoot对象

- 虚拟机栈（栈帧中的局部变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区常量引用的对象。
- 本地方法栈JNI（Native）方法的应用。

## Metaspace的组成

Metaspace由两大部分组成：Klass Metaspace和NoKlass Metaspace。

- **Klass Metaspace**
  - Klass Metaspace就是用来存**klass**的，就是class文件在jvm里的运行时数据结构
  - 这部分默认放在**Compressed Class Pointer Space**中，是一块连续的内存区域，

- **NoKlass Metaspace**
  - NoKlass Metaspace专门来存klass相关的其他的内容，比如method，constantPool等，可以由多块不连续的内存组成。

## 类加载过程

### 加载阶段

- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

### 连接阶段

- 验证：确保被加载的类的正确性

- 准备：为类的静态变量分配内存，并将其赋默认值

- 解析：将常量池中的符号引用替换为直接引用（内存地址）的过程

### 初始化

- 类的静态变量赋初值

- 在编译生成class文件时，编译器会产生两个方法加于class文件中，一个是类的初始化方法clinit, 另一个是实例的初始化方法init。 clinit指的是类构造器，主要作用是在类加载过程中的初始化阶段进行执行，执行内容包括静态变量初始化和静态块的执行。 init指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行。

## synchronized

### 原理

**它解决的是多线程之间访问贡献资源的同步问题，它保证了在被它修饰的方法或代码或代码块同一时间只有一个线程执行。**

> 因为java线程是映射到操作系统的线程之上的，所以暂停或唤醒线程都需要Java程序从**用户态转换到内核态**，这段时间消耗较长。

修饰同步代码块时，会在编译出来的字节码前后加上`monitorenter`和`monitorexit`。ObjectMonitor

**其实真正的锁应该是这个monitor cpp对象,synchronized锁的那个java对象起到的只是关联monitor的作用, 只不过我们身在java层面，无法感知到jvm层面monitor的作用，所以才称synchronized的java锁对象为锁。**

**每次执行monitorenter指令的时候,是将当前synchronized锁对象 关联的**monitor**的_recursions加1, 执行monitorexit指令的时候,将当前object对象关联的**monitor**的_recursions减1, 当_recursions为0的时候，就说明线程不再持有锁对象。**

### 锁升级过程

锁共有四种状态：无锁状态、偏向锁状态、轻量级锁状 态和重量级锁状态。

- 偏向锁
  - 当一个线程访问同步块并获取到锁时，会在对象头和栈帧中的锁记录中存储锁偏向的线程ID，该线程在进入和退出不需要CAS。如果获取失败，则需要在测试一下MarkWord中偏向锁的标识是否设置为1，如果设置了就用CAS将对象头的的偏向锁指向当前线程；如果没有则使用CAS竞争。
  - 偏向锁是等有竞争才释放，且需要等待全局安全点（这个时间点上没有正在执行的字节码）。栈中的锁记录和对象头的MarkWord要么重新偏向其他线程，要么恢复到无锁或者标记对象不合适作为偏向锁，最后唤醒暂停的线程。

- 轻量级锁
  - JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的MarkWord复制到锁记录中，称为displaced mark word。然后线程尝试使用CAS将对象头中MarkWord替换为指向锁记录的指针。如果成功，就获取到锁，如果失败则表明还有其他线程竞争锁，当前线程尝试自旋。
  - 解锁时，CAS将displaced MarkWord替换回到对象头，如果成功，则表明没有竞争发生，如果失败，表示有竞争，锁膨胀为重量级锁。

整个synchronized的实现本身就是基于CAS的 ，轻量级锁和偏向锁都是使用了CAS操作的，偏向锁是使用CAS修改java锁对象的对象头的markword的偏向线程ID，而轻量级锁是使用CAS修改整个MarkWord为指向线程栈帧的指针。

